var WebSheet =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(2);

	var _exprCompiler = __webpack_require__(6);

	var _exprCompiler2 = _interopRequireDefault(_exprCompiler);

	var _WebSheet = __webpack_require__(11);

	var _WebSheet2 = _interopRequireDefault(_WebSheet);

	var _WebSheetContext = __webpack_require__(16);

	var _WebSheetContext2 = _interopRequireDefault(_WebSheetContext);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_WebSheet2.default.parseExpression = _exprCompiler2.default;
	_WebSheet2.default.WebSheetContext = _WebSheetContext2.default;

	// This is because `export default` exports {default: WebSheet}
	module.exports = _WebSheet2.default;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(3);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./websheet.css", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./websheet.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports


	// module
	exports.push([module.id, ".websheet,\n.websheet *,\n.websheet *:before,\n.websheet *:after {\n    -webkit-box-sizing: content-box;\n    box-sizing: content-box;\n}\n\n.websheet.websheet-grabbing {\n    cursor: -webkit-grabbing;\n    cursor: grabbing;\n}\n\n.websheet-row {\n    display: block;\n    padding-right: 1px;\n}\n.websheet-row-sticky {\n    position: -webkit-sticky;\n    position: sticky;\n    top: 0;\n    z-index: 2;\n}\n\n.websheet-cell-wrapper {\n    border: 1px solid #000;\n    display: inline-block;\n    margin-bottom: -1px;\n    margin-right: -1px;\n    position: relative;\n    z-index: 1;\n}\n.websheet-cell-wrapper.websheet-has-focus {\n    border: 0;\n    cursor: -webkit-grab;\n    cursor: grab;\n    margin: -6px -6px -6px -5px !important; /* sorry not sorry */\n    padding: 6px;\n    z-index: 2;\n}\n.websheet-cell-wrapper:last-child {\n    margin-right: 0;\n}\n.websheet-row:last-child .websheet-cell-wrapper {\n    margin-bottom: 0;\n}\n\n.websheet-cell {\n    -moz-appearance: none;\n    -webkit-appearance: none;\n    background: transparent;\n    border: 0;\n    border-radius: 1px;\n    box-shadow: 0 0 0 0 rgba(51, 153, 255, 0.85);\n    display: block;\n    font-size: 13px;\n    height: 2em;\n    transition: box-shadow 0.15s, z-index 0.15s;\n    width: 100%;\n}\n.websheet-cell:focus {\n    border: 0 solid rgb(51, 153, 255);\n    box-shadow: 0 0 0 7px rgba(51, 153, 255, 0.85);\n    outline: none;\n}\n\n.websheet-cell-wrapper:after {\n    background: rgb(51, 153, 255);\n    border: 2px solid white;\n    border-radius: 4px;\n    bottom: 5px;\n    content: \"\";\n    display: block;\n    height: 5px;\n    opacity: 0;\n    position: absolute;\n    right: 5px;\n    transition: bottom 0.25s, right 0.25s, opacity 0.1s;\n    width: 5px;\n}\n\n.websheet-cell-wrapper.websheet-has-focus:after {\n    bottom: -4px;\n    cursor: crosshair;\n    opacity: 1;\n    right: -4px;\n}\n\n.websheet-cell-hover input {\n    background: rgb(51, 153, 255);\n    color: #fff;\n}\n", ""]);

	// exports


/***/ },
/* 4 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = parse;

	var _ExpressionToken = __webpack_require__(7);

	var _ExpressionToken2 = _interopRequireDefault(_ExpressionToken);

	var _ExpressionNode = __webpack_require__(8);

	var _ExpressionNode2 = _interopRequireDefault(_ExpressionNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var TOKEN_BOOL = /^(true|false)/i;
	var TOKEN_STRING = /^"([^\\]|\\.)*"/i;
	var TOKEN_CELL_ID = /^(\$?)(\w+)(\$?)(\d+)/i;
	var TOKEN_NUM = /^((([1-9][0-9]*\.|0\.)[0-9]+)|([1-9][0-9]*)|0)/;
	var TOKEN_BINOP_TIMES = /^(\/|\*|\^)/;
	var TOKEN_BINOP_ADD = /^(\+|\-|&)/;
	var TOKEN_BINOP_COMP = /^(<>|=|>=|<=|<|>)/;
	var TOKEN_FOPEN = /^(\w+)\(/;
	var TOKEN_XSOPEN = /^(\w+)!/;
	var TOKEN_RPAREN = /^\)/;
	var TOKEN_LPAREN = /^\(/;
	var TOKEN_COMMA = /^,/;
	var TOKEN_COLON = /^:/;
	var TOKEN_PERCENT = /^%/;
	var TOKEN_WS = /^\s+/;

	var PARSED_CACHE_THRESHOLD = 10;

	var parsedExpressionCount = {};
	var parsedExpressionCache = {};

	function parse(expression) {
	    if (expression in parsedExpressionCache) {
	        return parsedExpressionCache[expression].clone();
	    }

	    var lexIdx = 0;
	    function lex() {
	        var remainder = expression.substr(lexIdx);
	        if (!remainder) return 'EOF';
	        var matches;
	        var output;
	        if (matches = TOKEN_WS.exec(remainder)) {
	            lexIdx += matches[0].length;
	            return lex();
	        } else if (matches = TOKEN_BOOL.exec(remainder)) {
	            output = new _ExpressionToken2.default('boolean', matches[0].toLowerCase());
	        } else if (matches = TOKEN_STRING.exec(remainder)) {
	            output = new _ExpressionToken2.default('string', JSON.parse(matches[0]));
	        } else if (matches = TOKEN_NUM.exec(remainder)) {
	            output = new _ExpressionToken2.default('number', matches[0]);
	        } else if (matches = TOKEN_FOPEN.exec(remainder)) {
	            output = new _ExpressionToken2.default('funcopen', matches[1]);
	        } else if (matches = TOKEN_XSOPEN.exec(remainder)) {
	            output = new _ExpressionToken2.default('sheetref', matches[1]);
	        } else if (matches = TOKEN_CELL_ID.exec(remainder)) {
	            output = new _ExpressionToken2.default('ident', matches[0].toUpperCase());
	        } else if (matches = TOKEN_RPAREN.exec(remainder)) {
	            output = new _ExpressionToken2.default('rparen', ')');
	        } else if (matches = TOKEN_LPAREN.exec(remainder)) {
	            output = new _ExpressionToken2.default('lparen', '(');
	        } else if (matches = TOKEN_BINOP_TIMES.exec(remainder)) {
	            output = new _ExpressionToken2.default('binop_times', matches[0]);
	        } else if (matches = TOKEN_BINOP_ADD.exec(remainder)) {
	            output = new _ExpressionToken2.default('binop_add', matches[0]);
	        } else if (matches = TOKEN_BINOP_COMP.exec(remainder)) {
	            output = new _ExpressionToken2.default('binop_comp', matches[0]);
	        } else if (matches = TOKEN_COMMA.exec(remainder)) {
	            output = new _ExpressionToken2.default('comma', ',');
	        } else if (matches = TOKEN_PERCENT.exec(remainder)) {
	            output = new _ExpressionToken2.default('percent', '%');
	        } else if (matches = TOKEN_COLON.exec(remainder)) {
	            output = new _ExpressionToken2.default('colon', ':');
	        } else {
	            throw new SyntaxError('Unknown token: ' + remainder);
	        }
	        if (matches) {
	            lexIdx += matches[0].length;
	        }
	        return output;
	    }

	    var peeked;
	    function peek() {
	        return peeked = peeked || lex();
	    }
	    function pop() {
	        var output = peeked || lex();
	        peeked = null;
	        return output;
	    }
	    function accept(type) {
	        var peeked = peek();
	        if (!peeked || peeked.type !== type) return null;
	        return pop();
	    }
	    function assert(type) {
	        var popped = pop();
	        if (popped.type !== type) {
	            throw new SyntaxError('Expected ' + type + ', got ' + popped.type);
	        }
	        return popped;
	    }

	    function parsePrimitive() {
	        var accepted;
	        var negative = peek();
	        if (negative && negative.value === '-') {
	            negative = true;
	            pop();
	        } else {
	            negative = false;
	        }
	        if (accepted = accept('boolean')) {
	            return new _ExpressionNode2.default('boolean', { value: accepted.value === 'true' });
	        } else if (accepted = accept('number')) {
	            var raw = accepted.value;
	            var tmp = parseFloat(accepted.value);
	            if (accept('percent')) {
	                raw += '%';
	                tmp /= 100;
	            }
	            return new _ExpressionNode2.default('number', { value: tmp, raw: raw });
	        } else if (accepted = accept('string')) {
	            return new _ExpressionNode2.default('string', { value: accepted.value });
	        } else if (accepted = accept('ident')) {
	            var rematched = TOKEN_CELL_ID.exec(accepted.value);
	            return new _ExpressionNode2.default('identifier', {
	                value: rematched[2] + rematched[4],
	                pinRow: rematched[3] === '$',
	                pinCol: rematched[1] === '$',
	                raw: accepted.value
	            });
	        }

	        throw new SyntaxError('Unrecognized primitive value');
	    }
	    function parseRange() {
	        var base = parsePrimitive();
	        if (!base || base.type !== 'identifier') return base;
	        if (accept('colon')) {
	            var end = assert('ident');
	            base = new _ExpressionNode2.default('range', {
	                start: base,
	                end: new _ExpressionNode2.default('identifier', { value: end.value })
	            });
	        }
	        return base;
	    }
	    function parseFunc() {
	        var funcName = accept('funcopen');
	        if (!funcName) {
	            return parseRange();
	        }
	        var args = [];
	        while (peek()) {
	            if (accept('rparen')) break;
	            if (args.length) assert('comma');
	            args.push(parseExpression());
	        }
	        return new _ExpressionNode2.default('function', {
	            name: funcName.value,
	            args: args
	        });
	    }
	    function parseSheetRef() {
	        var sheetref = accept('sheetref');
	        if (!sheetref) {
	            return parseFunc();
	        }
	        return new _ExpressionNode2.default('sheetlookup', {
	            sheet: sheetref.value,
	            content: parseRange()
	        });
	    }
	    function parseParen() {
	        if (!accept('lparen')) {
	            return parseSheetRef();
	        }
	        var output = parseExpression();
	        assert('rparen');
	        return output;
	    }
	    function parseTimesBinop() {
	        var lval = parseParen();
	        var peeked = accept('binop_times');
	        if (!peeked) {
	            return lval;
	        }
	        return new _ExpressionNode2.default(peeked.value === '*' ? 'binop_mult' : peeked.value === '/' ? 'binop_div' : 'binop_expon', {
	            left: lval,
	            operator: peeked.value,
	            right: parseTimesBinop()
	        });
	    }
	    function parseAddBinop() {
	        var lval = parseTimesBinop();
	        var peeked = accept('binop_add');
	        if (!peeked) {
	            return lval;
	        }
	        return new _ExpressionNode2.default(peeked.value === '+' ? 'binop_add' : peeked.value === '&' ? 'binop_concat' : 'binop_sub', {
	            left: lval,
	            operator: peeked.value,
	            right: parseAddBinop()
	        });
	    }
	    function parseCompBinop() {
	        var lval = parseAddBinop();
	        var peeked = accept('binop_comp');
	        if (!peeked) {
	            return lval;
	        }
	        var name;
	        switch (peeked.value) {
	            case '<':
	                name = 'binop_comp_lt';break;
	            case '<=':
	                name = 'binop_comp_lte';break;
	            case '>':
	                name = 'binop_comp_gt';break;
	            case '>=':
	                name = 'binop_comp_gte';break;
	            case '=':
	                name = 'binop_comp_eq';break;
	            case '<>':
	                name = 'binop_comp_neq';break;
	        }
	        return new _ExpressionNode2.default(name, {
	            left: lval,
	            operator: peeked.value,
	            right: parseCompBinop()
	        });
	    }
	    function parseExpression() {
	        return parseCompBinop();
	    }

	    var output = parseExpression();

	    if (!(expression in parsedExpressionCount)) {
	        parsedExpressionCount[expression] = 1;
	    } else {
	        parsedExpressionCount[expression]++;
	        if (parsedExpressionCount[expression] >= PARSED_CACHE_THRESHOLD) {
	            parsedExpressionCache[expression] = output;
	        }
	    }

	    return output;
	};

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = ExpressionToken;
	function ExpressionToken(type, value) {
	    this.type = type;
	    this.value = value;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _functions = __webpack_require__(9);

	var _functions2 = _interopRequireDefault(_functions);

	var _cellID = __webpack_require__(10);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ExpressionNode = function () {
	    function ExpressionNode(type, params) {
	        _classCallCheck(this, ExpressionNode);

	        this.type = type;
	        for (var i in params) {
	            this[i] = params[i];
	        }
	    }

	    _createClass(ExpressionNode, [{
	        key: 'walk',
	        value: function walk(cb) {
	            if (cb(this) === false) return;
	            switch (this.type) {
	                case 'range':
	                    this.start.walk(cb);
	                    this.end.walk(cb);
	                    return;
	                case 'function':
	                    this.args.forEach(function (arg) {
	                        return arg.walk(cb);
	                    });
	                    return;
	                case 'sheetlookup':
	                    this.content.walk(cb);
	                    return;
	                case 'binop_mult':
	                case 'binop_div':
	                case 'binop_add':
	                case 'binop_sub':
	                case 'binop_concat':
	                case 'binop_expon':
	                    this.left.walk(cb);
	                    this.right.walk(cb);
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            switch (this.type) {
	                case 'boolean':
	                    return this.value ? 'true' : 'false';
	                case 'string':
	                    return JSON.stringify(this.value);
	                case 'number':
	                    return this.raw.toString();
	                case 'identifier':
	                    return this.raw.toUpperCase();
	                case 'sheetlookup':
	                    return this.sheet + '!' + this.content;
	                case 'range':
	                    return this.start + ':' + this.end;
	                case 'function':
	                    return this.name + '(' + this.args.map(function (a) {
	                        return a.toString();
	                    }).join(',') + ')';
	                case 'binop_mult':
	                    return this.left + '*' + this.right;
	                case 'binop_div':
	                    return this.left + '/' + this.right;
	                case 'binop_add':
	                    return this.left + '+' + this.right;
	                case 'binop_sub':
	                    return this.left + '-' + this.right;
	                case 'binop_concat':
	                    return this.left + '&' + this.right;
	                case 'binop_expon':
	                    return this.left + '^' + this.right;
	            }
	        }
	    }, {
	        key: 'clone',
	        value: function clone() {
	            switch (this.type) {
	                case 'boolean':
	                case 'string':
	                    return new ExpressionNode(this.type, { value: this.value });
	                case 'number':
	                    return new ExpressionNode(this.type, { value: this.value, raw: this.raw });
	                case 'identifier':
	                    return new ExpressionNode(this.type, { value: this.value, pinRow: this.pinRow, pinCol: this.pinCol, raw: this.raw });
	                case 'sheetlookup':
	                    return new ExpressionNode(this.type, { sheet: this.sheet, content: this.content.clone() });
	                case 'range':
	                    return new ExpressionNode(this.type, { start: this.start.clone(), end: this.end.clone() });
	                case 'function':
	                    return new ExpressionNode(this.type, { name: this.name, args: this.args.map(function (arg) {
	                            return arg.clone();
	                        }) });
	                case 'binop_mult':
	                case 'binop_div':
	                case 'binop_add':
	                case 'binop_sub':
	                case 'binop_concat':
	                case 'binop_expon':
	                    return new ExpressionNode(this.type, { left: this.left.clone(), right: this.right.clone() });
	            }
	        }
	    }, {
	        key: 'adjust',
	        value: function adjust(deltaRow, deltaCol) {
	            this.walk(function (x) {
	                if (x.type !== 'identifier') return;
	                var pos = (0, _cellID.getCellPos)(x.value);
	                var row = pos.row + (x.pinRow ? 0 : deltaRow);
	                var col = pos.col + (x.pinCol ? 0 : deltaCol);
	                x.value = (0, _cellID.getCellID)(row, col);
	                var rematched = TOKEN_CELL_ID.exec(x.value);
	                x.raw = (x.pinCol ? '$' : '') + rematched[2] + (x.pinRow ? '$' : '') + rematched[4];
	            });
	        }
	    }, {
	        key: 'findCellDependencies',
	        value: function findCellDependencies(cb) {
	            this.walk(function (node) {
	                if (node.type === 'identifier') {
	                    cb(node.value);
	                } else if (node.type === 'range') {
	                    iterateRangeNode(node, function (row, col) {
	                        return cb((0, _cellID.getCellID)(row, col));
	                    });
	                } else if (node.type === 'sheetlookup') {
	                    return false; // Kills traversal; handled by findSheetDependencies
	                }
	            });
	        }
	    }, {
	        key: 'findSheetDependencies',
	        value: function findSheetDependencies(cb) {
	            this.walk(function (node) {
	                if (node.type !== 'sheetlookup') {
	                    return;
	                }
	                node.content.findCellDependencies(function (cellID) {
	                    return cb(node.sheet, cellID);
	                });
	                return false;
	            });
	        }
	    }, {
	        key: 'run',
	        value: function run(sheet) {
	            switch (this.type) {
	                case 'boolean':
	                case 'number':
	                case 'string':
	                    return this.value;
	                case 'identifier':
	                    return sheet.getCalculatedValueAtID(this.value);
	                case 'sheetlookup':
	                    return this.content.run(sheet.getSheet(this.sheet));
	                case 'binop_mult':
	                    return this.left.run(sheet) * this.right.run(sheet);
	                case 'binop_div':
	                    return this.left.run(sheet) / this.right.run(sheet);
	                case 'binop_add':
	                    return parseFloat(this.left.run(sheet)) + parseFloat(this.right.run(sheet));
	                case 'binop_sub':
	                    return this.left.run(sheet) - this.right.run(sheet);
	                case 'binop_concat':
	                    return this.left.run(sheet).toString() + this.right.run(sheet).toString();
	                case 'binop_expon':
	                    return Math.pow(this.left.run(sheet), this.right.run(sheet));
	                case 'binop_comp_lt':
	                    return parseFloat(this.left.run(sheet)) < parseFloat(this.right.run(sheet));
	                case 'binop_comp_lte':
	                    return parseFloat(this.left.run(sheet)) <= parseFloat(this.right.run(sheet));
	                case 'binop_comp_gt':
	                    return parseFloat(this.left.run(sheet)) > parseFloat(this.right.run(sheet));
	                case 'binop_comp_gte':
	                    return parseFloat(this.left.run(sheet)) >= parseFloat(this.right.run(sheet));
	                case 'binop_comp_eq':
	                    return this.left.run(sheet) == this.right.run(sheet);
	                case 'binop_comp_neq':
	                    return this.left.run(sheet) != this.right.run(sheet);
	                case 'range':
	                    var rangeCells = [];
	                    iterateRangeNode(this, function (row, col) {
	                        rangeCells.push((0, _functions.parseNumMaybe)(sheet.getCalculatedValueAtPos(row, col)));
	                    });
	                    return rangeCells;
	            }
	            if (this.type !== 'function') {
	                throw new TypeError('Unknown exression node');
	            }
	            return (0, _functions2.default)(this.name, this.args, sheet);
	        }
	    }, {
	        key: 'compile',
	        value: function compile(sheet) {
	            function castNum(x) {
	                var compiled = x.compile();
	                if (x.compiledReturnType() === 'num') return compiled;
	                return 'parseFloat(' + compiled + ')';
	            }

	            switch (this.type) {
	                case 'boolean':
	                case 'number':
	                case 'string':
	                    return this.toString();
	                case 'identifier':
	                    return 'sheet.getCalculatedValueAtID(' + JSON.stringify(this.value) + ')';
	                case 'sheetlookup':
	                    return '(function(sheet){' + this.content.compile() + '}(sheet.getSheet(' + JSON.stringify(this.sheet) + ')))';
	                case 'binop_mult':
	                    return '(' + this.left.compile() + '*' + this.right.compile() + ')';
	                case 'binop_div':
	                    return '(' + this.left.compile() + '/' + this.right.compile() + ')';
	                case 'binop_add':
	                    return '(' + castNum(this.left) + '+' + castNum(this.right) + ')';
	                case 'binop_sub':
	                    return '(' + this.left.compile() + '-' + this.right.compile() + ')';
	                case 'binop_concat':
	                    return '((' + this.left.compile() + ').toString()+(' + this.right.compile() + ').toString())';
	                case 'binop_expon':
	                    return 'Math.pow(' + this.left.compile() + ', ' + this.right.compile() + ')';
	                case 'binop_comp_lt':
	                    return '(' + castNum(this.left) + ' < ' + castNum(this.right) + ')';
	                case 'binop_comp_lte':
	                    return '(' + castNum(this.left) + ' <= ' + castNum(this.right) + ')';
	                case 'binop_comp_gt':
	                    return '(' + castNum(this.left) + ' > ' + castNum(this.right) + ')';
	                case 'binop_comp_gte':
	                    return '(' + castNum(this.left) + ' >= ' + castNum(this.right) + ')';
	                case 'binop_comp_eq':
	                    return '(' + this.left.compile() + ' == ' + this.right.compile() + ')';
	                case 'binop_comp_neq':
	                    return '(' + this.left.compile() + ' != ' + this.right.compile() + ')';

	                case 'range':
	                    var rangeCells = [];
	                    iterateRangeNode(this, function (row, col) {
	                        rangeCells.push('parseNumMaybe(sheet.getCalculatedValueAtPos(' + row + ', ' + col + '))');
	                    });
	                    return rangeCells.join(',');
	                case 'function':
	                    return 'execFunc(' + JSON.stringify(this.name) + ',[' + this.args.map(function (x) {
	                        return x.compile();
	                    }).join(',') + '], sheet)';
	                default:
	                    throw new TypeError('Cannot compile unknown expression nodes');
	            }
	        }
	    }, {
	        key: 'compiledReturnType',
	        value: function compiledReturnType() {
	            switch (this.type) {
	                case 'boolean':
	                    return 'bool';
	                case 'number':
	                    return 'num';
	                case 'string':
	                    return 'str';
	                case 'identifier':
	                    return 'mixed';
	                case 'sheetlookup':
	                    return 'mixed';
	                case 'binop_mult':
	                    return 'num';
	                case 'binop_div':
	                    return 'num';
	                case 'binop_add':
	                    return 'num';
	                case 'binop_sub':
	                    return 'num';
	                case 'binop_concat':
	                    return 'str';
	                case 'binop_expon':
	                    return 'num';
	                case 'binop_comp_lt':
	                    return 'bool';
	                case 'binop_comp_lte':
	                    return 'bool';
	                case 'binop_comp_gt':
	                    return 'bool';
	                case 'binop_comp_gte':
	                    return 'bool';
	                case 'binop_comp_eq':
	                    return 'bool';
	                case 'binop_comp_neq':
	                    return 'bool';
	                case 'range':
	                    return 'arr';
	                case 'function':
	                    return 'mixed';
	            }

	            return 'mixed';
	        }
	    }]);

	    return ExpressionNode;
	}();

	exports.default = ExpressionNode;
	;

	function iterateRangeNode(node, cb) {
	    var start = (0, _cellID.getCellPos)(node.start.value);
	    var end = (0, _cellID.getCellPos)(node.end.value);
	    var rowStart = Math.min(start.row, end.row);
	    var rowEnd = Math.max(start.row, end.row);
	    var colStart = Math.min(start.col, end.col);
	    var colEnd = Math.max(start.col, end.col);
	    for (var i = rowStart; i <= rowEnd; i++) {
	        for (var j = colStart; j <= colEnd; j++) {
	            cb(i, j);
	        }
	    }
	}

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = execFunc;
	exports.parseNumMaybe = parseNumMaybe;

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var directExprFuncs = {};
	function registerDirectFunc(base, method, alias) {
	    directExprFuncs[alias || method] = base[method].bind(base);
	}

	registerDirectFunc(Math, 'abs');
	registerDirectFunc(Math, 'acos');
	registerDirectFunc(Math, 'acosh');
	registerDirectFunc(Math, 'asin');
	registerDirectFunc(Math, 'asinh');
	registerDirectFunc(Math, 'atan');
	registerDirectFunc(Math, 'atan2');
	registerDirectFunc(Math, 'atanh');
	registerDirectFunc(Math, 'ceil');
	registerDirectFunc(Math, 'ceil', 'ceiling');
	registerDirectFunc(Math, 'cos');
	registerDirectFunc(Math, 'cosh');
	registerDirectFunc(Math, 'exp');
	registerDirectFunc(Math, 'floor', 'int');
	registerDirectFunc(Math, 'floor');
	registerDirectFunc(Math, 'log', 'ln');
	registerDirectFunc(Math, 'log10', 'log10');
	registerDirectFunc(Math, 'pow', 'power');
	registerDirectFunc(Math, 'pow');
	registerDirectFunc(Math, 'random', 'rand');
	registerDirectFunc(Math, 'random');
	registerDirectFunc(Math, 'sin');
	registerDirectFunc(Math, 'sinh');
	registerDirectFunc(Math, 'sqrt');
	registerDirectFunc(Math, 'tan');
	registerDirectFunc(Math, 'tanh');

	registerDirectFunc(String, 'fromCharCode', 'char');

	function execFunc(name, myArgs, sheet) {
	    var _Math, _Math2, _Math3, _Math4;

	    var args = [];
	    for (var argI = 0; argI < myArgs.length; argI++) {
	        var argTmp = myArgs[argI].run(sheet);
	        if (argTmp && (typeof argTmp === 'undefined' ? 'undefined' : _typeof(argTmp)) === 'object') {
	            args = args.concat(argTmp);
	        } else {
	            args.push(argTmp);
	        }
	    }

	    name = name.toLowerCase();
	    if (name in directExprFuncs) {
	        return directExprFuncs[name].apply(directExprFuncs, _toConsumableArray(args));
	    }

	    var tmp;
	    var tmp2;
	    switch (name) {
	        case 'and':
	            return args.every(parseNumAlways);
	        case 'average':
	            tmp = args.filter(isNotNaNAsFloat);
	            return tmp.length ? tmp.reduce(add) / tmp.length : 0;
	        case 'averagea':
	            return args.map(parseNumAlways).reduce(add) / args.length;
	        case 'code':
	        case 'asc':
	            return args[0].toString().charCodeAt(0) || 0;
	        case 'chr':
	        case 'combin':
	            return factorial(args[0]) / factorial(args[0] - args[1]);
	        case 'concatenate':
	            return args.reduce(function (a, b) {
	                return a.toString() + b.toString();
	            });
	        case 'count':
	            return args.filter(isNotNaNAsFloat).length;
	        case 'counta':
	            return args.filter(function (x) {
	                return x !== '' && x !== null && x !== undefined;
	            }).length;
	        case 'countblank':
	            return args.filter(function (x) {
	                return x === '';
	            }).length;
	        case 'countif':
	            return args.filter(function (x) {
	                return x == args[1];
	            }).length;
	        case 'degrees':
	            return args[0] * 57.2957795;
	        case 'dollar':
	            return '$' + commas(args[0] | 0) + (args[1] ? '.' + parseFloat(args[0]).toFixed(args[1]).split('.')[1] : '');
	        case 'even':
	            return Math.ceil(args[0] / 2) * 2;
	        case 'exact':
	            return args[0].toString() === args[1].toString();
	        case 'fact':
	            return factorial(args[0]);
	        case 'factdouble':
	            return factorial(args[0], 2);
	        case 'search':
	        case 'find':
	            return args[1].toString().substr((args[2] || 1) - 1).indexOf(args[0].toString());
	        case 'fixed':
	            return (args[2] ? function (x) {
	                return x;
	            } : commas)(args[0]) + (args[1] ? '.' + parseFloat(args[0]).toFixed(args[1]).split('.')[1] : '');
	        case 'frequency':
	            return args.slice(0, -1).filter(function (x) {
	                return x <= args[args.length - 1];
	            }).length;
	        case 'if':
	            return args[0] ? args[1] : args[2];
	        case 'isblank':
	            return args[0] === '' || args[0] === null;
	        case 'iseven':
	            return args[0] % 2 === 0;
	        case 'isnottext':
	            return typeof args[0] !== 'string';
	        case 'isnumber':
	            return typeof args[0] === 'number';
	        case 'isodd':
	            return args[0] % 2 !== 0;
	        case 'istext':
	            return typeof args[0] === 'string';
	        case 'large':
	            return args.slice(0, -1).sort().reverse()[args[args.length - 1]];
	        case 'lower':
	        case 'lcase':
	            return args[0].toString().toLowerCase();
	        case 'left':
	            return args[0].toString().substr(0, args[1] || 1);
	        case 'len':
	            return args[0].toString().length;
	        case 'max':
	            return (_Math = Math).max.apply(_Math, _toConsumableArray(args.filter(isNotNaNAsFloat)));
	        case 'maxa':
	            return (_Math2 = Math).max.apply(_Math2, _toConsumableArray(args.map(parseNumAlways)));
	        case 'median':
	            tmp = args.map(parseFloat).sort();
	            return tmp.length % 2 === 0 ? (tmp[(tmp.length - 1) / 2 | 0] + tmp[Math.ceil((tmp.length - 1) / 2)]) / 2 : tmp[(tmp.length - 1) / 2];
	        case 'mid':
	            return args[0].toString().substr((args[1] || 1) - 1, args[2]);
	        case 'min':
	            return (_Math3 = Math).min.apply(_Math3, _toConsumableArray(args.filter(isNotNaNAsFloat)));
	        case 'mina':
	            return (_Math4 = Math).min.apply(_Math4, _toConsumableArray(args.map(parseNumAlways)));
	        case 'mod':
	            return args[0] % args[1];
	        case 'not':
	            return !args[0];
	        case 'or':
	            return args.reduce(function (a, b) {
	                return a || b;
	            });
	        case 'pi':
	            return Math.PI;
	        case 'product':
	            return args.reduce(function (a, b) {
	                return a * b;
	            });
	        case 'proper':
	            return args[0].toString().split(/\s/).map(function (s) {
	                return s[0].toUpperCase() + s.substr(1);
	            });
	        case 'quotient':
	            return args[0] / args[1] | 0;
	        case 'radians':
	            return args[0] / 57.2957795;
	        case 'randbetween':
	            return Math.random() * (args[1] - args[0]) + args[0];
	        case 'replace':
	            return args[0].toString().substr(0, args[1] - 1) + args[3].toString() + args[0].toString().substr(args[1] - 1 + args[2]);
	        case 'rept':
	            return new Array(args[1] + 1).join(args[0].toString());
	        case 'right':
	            return args[0].toString().substr(-1 * args[1] || -1);
	        case 'round':
	            return Math.round(args[0] || 0).toFixed(args[1] || 0);
	        case 'fix':
	        case 'rounddown':
	            return args[0] < 0 ? Math.ceil(args[0]) : Math.floor(args[0]);
	        case 'roundup':
	            return args[0] > 0 ? Math.ceil(args[0]) : Math.floor(args[0]);
	        case 'sign':
	            return args[0] / Math.abs(args[0]) || 0;
	        case 'space':
	            return new Array(args[0] + 1).join(' ');
	        case 'sqrtpi':
	            return Math.sqrt(args[0] * Math.PI);
	        case 'stdev':
	            tmp = args.filter(isNotNaNAsFloat).map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return Math.sqrt(tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / (tmp.length - 1));
	        case 'stdeva':
	            tmp = args.map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return Math.sqrt(tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / (tmp.length - 1));
	        case 'stdevp':
	            tmp = args.filter(isNotNaNAsFloat).map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return Math.sqrt(tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / tmp.length);
	        case 'stdevpa':
	            tmp = args.map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return Math.sqrt(tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / tmp.length);
	        case 't':
	        case 'str':
	            return args[0].toString();
	        case 'sum':
	            return args.map(parseNumAlways).reduce(add);
	        case 'upper':
	        case 'ucase':
	            return args[0].toString().toUpperCase();
	        case 'value':
	        case 'val':
	            return (/^\d+/.exec(args[0].toString().replace(/\s/g, '')) || [''])[0];
	        case 'var':
	            tmp = args.filter(isNotNaNAsFloat).map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / (tmp.length - 1);
	        case 'vara':
	            tmp = args.map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / (tmp.length - 1);
	        case 'varp':
	            tmp = args.filter(isNotNaNAsFloat).map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / tmp.length;
	        case 'varpa':
	            tmp = args.map(parseNumAlways);
	            tmp2 = tmp.reduce(add) / tmp.length;
	            return tmp.map(function (x) {
	                return Math.pow(x - tmp2, 2);
	            }).reduce(add) / tmp.length;
	    }
	};

	var factorialCache = [];
	function factorial(n) {
	    var modifier = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

	    if (!modifier && n > 2 && factorialCache[n]) {
	        return factorialCache[n];
	    }
	    var output = n < 2 ? n : n * factorial(n - modifier);
	    if (!modifier) {
	        factorialCache[n] = output;
	    }
	    return output;
	}

	function add(a, b) {
	    return a + b;
	}

	function commas(num) {
	    return num.toString().split(/(?=(?:\d\d\d)*$)/).join(',');
	}

	function isNotNaNAsFloat(value) {
	    return !isNaN(parseFloat(value));
	}

	function parseNumMaybe(value) {
	    var parsed = parseFloat(value);
	    return isNaN(parsed) ? value : parsed;
	};

	function parseNumAlways(value) {
	    var parsed = parseFloat(value);
	    return isNaN(parsed) ? value ? 1 : 0 : parsed;
	}

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getCellID = getCellID;
	exports.getCellPos = getCellPos;
	function getCellID(row, column) {
	    var base = '';

	    row += 1;

	    do {
	        var character = column % 26;
	        column -= character;
	        column /= 26;
	        base = String.fromCharCode(character + 65) + base;
	    } while (column);

	    return base + row;
	};

	var cellPosCache = {};
	function getCellPos(id) {
	    if (id in cellPosCache) return cellPosCache[id];
	    var matches = /^([a-z]+)([0-9]+)$/i.exec(id);
	    var charBit = matches[1];
	    var col = 0;
	    while (charBit) {
	        var character = charBit.charCodeAt(0) - 65;
	        col *= 26;
	        col += character;
	        charBit = charBit.substr(1);
	    }
	    var output = new CellPosition(col, matches[2] - 1);
	    cellPosCache[id] = output;
	    return output;
	};

	function CellPosition(col, row) {
	    this.col = col;
	    this.row = row;
	}

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _constants = __webpack_require__(12);

	var _Emitter = __webpack_require__(13);

	var _Emitter2 = _interopRequireDefault(_Emitter);

	var _cellID = __webpack_require__(10);

	var _WebSheet = __webpack_require__(14);

	var _events = __webpack_require__(15);

	var _exprCompiler = __webpack_require__(6);

	var _exprCompiler2 = _interopRequireDefault(_exprCompiler);

	var _functions = __webpack_require__(9);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DEFAULT_COLUMN_WIDTH = 100; // px
	var DEFAULT_BORDER_WIDTH = 1; // px

	var defaultParams = {
	    width: 6,
	    height: 6
	};

	var WINDOW_MOUSEUP = Symbol('window.onmouseup');

	var WebSheet = function () {
	    function WebSheet(elem) {
	        var _this = this;

	        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        _classCallCheck(this, WebSheet);

	        this.elem = elem;
	        this.elem.className = 'websheet';

	        Object.assign(params, defaultParams);
	        this.height = params.height;
	        this.width = params.width;

	        this.columnWidths = [];
	        for (var i = 0; i < params.width; i++) {
	            this.columnWidths[i] = DEFAULT_COLUMN_WIDTH;
	        }

	        this.data = [];
	        this.calculated = [];
	        this.formatting = [];

	        this.depUpdateQueue = null;
	        this.dependencies = {}; // Map of cell ID to array of dependant cell IDs
	        this.dependants = {}; // Map of cell ID to array of dependencies

	        this.cellCache = {};

	        this.dragType = _constants.DRAG_NONE;
	        this.dragSource = null;

	        (0, _events.listen)(window, 'mouseup', this[WINDOW_MOUSEUP] = function (e) {
	            if (_this.dragType === _constants.DRAG_NONE) {
	                return;
	            }
	            _this.dragType = _constants.DRAG_NONE;
	            _this.dragSource = null;
	            _this.elem.className = 'websheet';
	        });

	        this.valueUpdates = new _Emitter2.default();
	        this.calculatedUpdates = new _Emitter2.default();

	        this.context = params.context || null;
	        this.name = null;
	    }

	    _createClass(WebSheet, [{
	        key: 'addColumn',
	        value: function addColumn() {
	            this.width += 1;
	            this.columnWidths.push(DEFAULT_COLUMN_WIDTH);
	            this.forceRerender();
	        }
	    }, {
	        key: 'addRow',
	        value: function addRow() {
	            this.height += 1;
	            this.data.push(new Array(this.width));
	            this.calculated.push(new Array(this.width));
	            this.formatting.push(new Array(this.width));
	            this.forceRerender();
	        }
	    }, {
	        key: 'calculateValueAtPosition',
	        value: function calculateValueAtPosition(row, col, expression) {
	            var _this2 = this;

	            if (!expression) return;
	            var cellID = (0, _cellID.getCellID)(row, col);

	            // Parse the expression
	            var parsed = (0, _exprCompiler2.default)(expression);

	            // Evaluate the expression to find a value
	            var value;
	            try {
	                value = parsed.run(this);
	                if (isNaN(value)) value = '#VALUE!';
	            } catch (e) {
	                throw e;
	                console.error(e);
	                value = '#ERROR!';
	                parsed = null;
	            }

	            // Set the calculated value in the calculated cache
	            this.calculated[row] = this.calculated[row] || [];

	            var wasUpdated = this.calculated[row][col] !== value;
	            if (wasUpdated) {
	                this.calculated[row][col] = value;
	            }

	            // Set the dependants
	            var dependants = [];
	            if (parsed) {
	                // Bind intra-sheet dependencies
	                parsed.findCellDependencies(function (dep) {
	                    if (dependants.indexOf(dep) !== -1) return;
	                    dependants.push(dep);
	                    var deps;
	                    if (!(dep in _this2.dependencies)) {
	                        _this2.dependencies[dep] = [cellID];
	                    } else if ((deps = _this2.dependencies[dep]) && deps.indexOf(cellID) === -1) {
	                        deps.push(cellID);
	                    }
	                });

	                // Bind inter-sheet dependencies if a sheet context exists
	                if (this.context) {
	                    (function () {
	                        _this2.context.clearDependencies(_this2, cellID);
	                        var sheetDeps = [];
	                        parsed.findSheetDependencies(function (sheet, dep) {
	                            if (!_this2.context.sheets[sheet.toUpperCase()]) return;
	                            var depName = sheet + '!' + dep;
	                            if (sheetDeps.indexOf(depName) !== -1) return;
	                            sheetDeps.push(depName);

	                            _this2.context.setDependency(_this2, cellID, sheet, dep, function () {
	                                _this2.calculateValueAtPosition(row, col, expression);
	                            });
	                        });
	                    })();
	                }
	            }
	            this.dependants[cellID] = dependants;

	            // Set the value of the element
	            this.getCell(cellID).value = value;

	            if (wasUpdated) {
	                this.updateDependencies(cellID);
	                this.calculatedUpdates.fire(cellID, value);
	            }
	        }
	    }, {
	        key: 'clearCell',
	        value: function clearCell(row, col) {
	            var cellID = (0, _cellID.getCellID)(row, col);
	            var elem = this.getCell(cellID);
	            if (!elem) return;

	            elem.value = '';
	            if (row in this.data) delete this.data[row][col];
	            if (row in this.calculated) delete this.calculated[row][col];
	            this.clearDependants(cellID);
	            this.dependants[cellID] = [];
	        }
	    }, {
	        key: 'clearDependants',
	        value: function clearDependants(id) {
	            var deps = this.dependants[id];
	            if (!deps) return;

	            for (var i = 0; i < deps.length; i++) {
	                var remDeps = this.dependencies[deps[i]];
	                if (!remDeps) continue;
	                var idx = remDeps.indexOf(id);
	                if (idx !== -1) remDeps.splice(idx, 1);
	            }

	            if (!this.context) return;
	            this.context.clearDependencies(this, id);
	        }
	    }, {
	        key: 'forceRerender',
	        value: function forceRerender() {
	            var _this3 = this;

	            // First, update the element to be the correct dimensions.
	            var width = this.columnWidths.reduce(function (a, b) {
	                return a + b;
	            }); // Get the width of each column
	            width += DEFAULT_BORDER_WIDTH;
	            // width -= this.width * DEFAULT_BORDER_WIDTH; // Account for border widths
	            this.elem.style.width = width + 'px';

	            while (this.elem.childNodes.length) {
	                this.elem.removeChild(this.elem.firstChild);
	            }
	            this.cellCache = {};

	            var workQueue = [];

	            // Create each row and cell
	            for (var i = 0; i < this.height; i++) {
	                var row = document.createElement('div');
	                row.style.width = width + 'px';
	                row.className = 'websheet-row';
	                if (i < 1) {
	                    row.className += ' websheet-row-sticky';
	                }
	                this.elem.appendChild(row);

	                var rowDataCache = this.data[i] || [];
	                var rowCalculatedCache = this.calculated[i] || [];
	                var rowFormattingCache = this.formatting[i] || [];

	                var _loop = function _loop() {
	                    var cell = document.createElement('input');
	                    cell.className = 'websheet-cell';

	                    var cellWrapper = document.createElement('div');
	                    cellWrapper.className = 'websheet-cell-wrapper';
	                    cellWrapper.style.width = _this3.columnWidths[j] - 1 + 'px';
	                    cellWrapper.appendChild(cell);

	                    row.appendChild(cellWrapper);

	                    cell.value = rowCalculatedCache[j] || rowDataCache[j] || '';
	                    cell.setAttribute('data-id', cell.title = (0, _cellID.getCellID)(i, j));
	                    cell.setAttribute('data-id-prev-col', (0, _cellID.getCellID)(i, j - 1));
	                    cell.setAttribute('data-id-prev-row', (0, _cellID.getCellID)(i - 1, j));
	                    cell.setAttribute('data-id-next-col', (0, _cellID.getCellID)(i, j + 1));
	                    cell.setAttribute('data-id-next-row', (0, _cellID.getCellID)(i + 1, j));
	                    cell.setAttribute('data-row', i);
	                    cell.setAttribute('data-col', j);

	                    if (cell.value[0] === '=') {
	                        workQueue.push(function () {
	                            return _this3.setValueAtPosition(i, j, cell.value, true);
	                        });
	                    }

	                    var cellFormatting = rowFormattingCache[j];
	                    if (!cellFormatting) return 'continue';
	                    for (var cellFormattingStyle in cellFormatting) {
	                        if (!cellFormatting.hasOwnProperty(cellFormattingStyle)) continue;
	                        cell.style[cellFormattingStyle] = cellFormatting[cellFormattingStyle];
	                    }
	                };

	                for (var j = 0; j < this.width; j++) {
	                    var _ret2 = _loop();

	                    if (_ret2 === 'continue') continue;
	                }
	            }

	            // Bind event handlers
	            (0, _WebSheet.initEvents)(this);

	            workQueue.forEach(function (task) {
	                return task();
	            });
	        }
	    }, {
	        key: 'getCalculatedValueAtID',
	        value: function getCalculatedValueAtID(id) {
	            var pos = (0, _cellID.getCellPos)(id);
	            return this.getCalculatedValueAtPos(pos.row, pos.col);
	        }
	    }, {
	        key: 'getCalculatedValueAtPos',
	        value: function getCalculatedValueAtPos(row, col) {
	            return (0, _functions.parseNumMaybe)((this.calculated[row] || [])[col] || (this.data[row] || [])[col] || 0);
	        }
	    }, {
	        key: 'getCell',
	        value: function getCell(id) {
	            if (id in this.cellCache) return this.cellCache[id];
	            return this.cellCache[id] = this.elem.querySelector('[data-id="' + id + '"]');
	        }
	    }, {
	        key: 'getSheet',
	        value: function getSheet(name) {
	            if (!this.context) throw new Error('No context to extract sheet from');
	            name = name.toUpperCase();
	            if (!(name in this.context.sheets)) throw new Error('Undefined sheet requested');
	            return this.context.sheets[name];
	        }
	    }, {
	        key: 'getValueAtPos',
	        value: function getValueAtPos(row, col) {
	            return (this.data[row] || [])[col] || null;
	        }
	    }, {
	        key: 'insertColumnBefore',
	        value: function insertColumnBefore(idx) {
	            this.width += 1;
	            this.columnWidths.splice(idx, 0, DEFAULT_COLUMN_WIDTH);
	            for (var i = 0; i < this.height; i++) {
	                if (this.data[i]) this.data[i].splice(idx, 0, null);
	                if (this.calculated[i]) this.calculated[i].splice(idx, 0, null);
	                if (this.formatting[i]) this.formatting[i].splice(idx, 0, null);
	            }
	            this.forceRerender();
	        }
	    }, {
	        key: 'insertRowBefore',
	        value: function insertRowBefore(idx) {
	            this.height += 1;
	            this.data.splice(idx, 0, new Array(this.width));
	            this.calculated.splice(idx, 0, new Array(this.width));
	            this.formatting.splice(idx, 0, new Array(this.width));
	            this.forceRerender();
	        }
	    }, {
	        key: 'loadData',
	        value: function loadData(data) {
	            while (this.height < data.length) {
	                this.addRow();
	            }while (this.width < data[0].length) {
	                this.addColumn();
	            }for (var i = 0; i < data.length; i++) {
	                this.data[i] = this.data[i] || [];
	                for (var j = 0; j < data[i].length; j++) {
	                    this.data[i][j] = data[i][j];
	                }
	            }
	            this.forceRerender();
	        }
	    }, {
	        key: 'popColumn',
	        value: function popColumn() {
	            if (this.width < 2) throw new Error('Cannot make spreadsheet that small');
	            this.width -= 1;
	            this.columnWidths.pop();
	            for (var i = 0; i < this.height; i++) {
	                if (this.data[i] && this.data[i].length > this.width) this.data[i].pop();
	                if (this.calculated[i] && this.calculated[i].length > this.width) this.calculated[i].pop();
	                if (this.formatting[i] && this.formatting[i].length > this.width) this.formatting[i].pop();
	            }
	            this.forceRerender();
	        }
	    }, {
	        key: 'popRow',
	        value: function popRow() {
	            if (this.height < 2) throw new Error('Cannot make spreadsheet that small');
	            this.height -= 1;
	            this.data.pop();
	            this.calculated.pop();
	            this.formatting.pop();
	            this.forceRerender();
	        }
	    }, {
	        key: 'removeColumn',
	        value: function removeColumn(idx) {
	            if (this.width < 2) throw new Error('Cannot make spreadsheet that small');
	            if (idx < 0 || idx >= this.width) throw new Error('Removing cells that do not exist');
	            this.width -= 1;
	            this.columnWidths.splice(idx, 1);
	            for (var i = 0; i < this.height; i++) {
	                if (this.data[i]) this.data[i].splice(idx, 1);
	                if (this.calculated[i]) this.calculated[i].splice(idx, 1);
	                if (this.formatting[i]) this.formatting[i].splice(idx, 1);
	            }
	            this.forceRerender();
	        }
	    }, {
	        key: 'removeRow',
	        value: function removeRow(i) {
	            if (this.height < 2) throw new Error('Cannot make spreadsheet that small');
	            if (i < 0 || i >= this.width) throw new Error('Removing cells that do not exist');
	            this.height -= 1;
	            this.data.splice(i, 1);
	            this.calculated.splice(i, 1);
	            this.formatting.splice(i, 1);
	            this.forceRerender();
	        }
	    }, {
	        key: 'setValueAtPosition',
	        value: function setValueAtPosition(row, col, value) {
	            var force = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

	            var cellID = (0, _cellID.getCellID)(row, col);
	            var elem = this.getCell(cellID);

	            this.data[row] = this.data[row] || [];
	            if (this.data[row][col] === value && !force) {
	                return;
	            }

	            this.data[row][col] = value;
	            if (this.calculated[row]) {
	                delete this.calculated[row][col];
	            }

	            this.clearDependants(cellID);

	            this.valueUpdates.fire(cellID, value);

	            if (value[0] === '=') {
	                this.calculateValueAtPosition(row, col, value.substr(1));
	            } else {
	                this.updateDependencies(cellID);
	                if (elem) elem.value = value;
	            }
	        }
	    }, {
	        key: 'updateDependencies',
	        value: function updateDependencies(cellID) {
	            var deps = this.dependencies[cellID];
	            if (!deps) return;

	            if (this.depUpdateQueue) {
	                for (var i = 0; i < deps.length; i++) {
	                    if (this.depUpdateQueue.indexOf(deps[i]) !== -1) continue;
	                    this.depUpdateQueue.push(deps[i]);
	                }
	                return;
	            }

	            this.depUpdateQueue = deps.concat([]); // Make a copy
	            for (var i = 0; i < deps.length; i++) {
	                this.depUpdateQueue.push(deps[i]);
	            }

	            while (this.depUpdateQueue.length) {
	                var _getCellPos = (0, _cellID.getCellPos)(this.depUpdateQueue.shift());

	                var row = _getCellPos.row;
	                var col = _getCellPos.col;

	                this.calculateValueAtPosition(row, col, this.data[row][col].substr(1));
	            }

	            this.depUpdateQueue = null;
	        }
	    }]);

	    return WebSheet;
	}();

	exports.default = WebSheet;
	;

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var DRAG_HANDLE = exports.DRAG_HANDLE = 2;
	var DRAG_MOVE = exports.DRAG_MOVE = 1;
	var DRAG_NONE = exports.DRAG_NONE = 0;

/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Emitter = function () {
	    function Emitter() {
	        _classCallCheck(this, Emitter);

	        this.listeners = {};
	        this.allListeners = [];
	    }

	    _createClass(Emitter, [{
	        key: "fire",
	        value: function fire(name) {
	            var i;
	            for (i = 0; i < this.allListeners.length; i++) {
	                var _allListeners;

	                (_allListeners = this.allListeners)[i].apply(_allListeners, arguments);
	            }
	            if (!(name in this.listeners)) return;
	            var args = Array.prototype.slice.call(arguments, 1);
	            for (i = 0; i < this.listeners[name].length; i++) {
	                var _listeners$name;

	                (_listeners$name = this.listeners[name])[i].apply(_listeners$name, _toConsumableArray(args));
	            }
	        }
	    }, {
	        key: "on",
	        value: function on(name, listener) {
	            if (!(name in this.listeners)) {
	                this.listeners[name] = [];
	            }
	            this.listeners[name].push(listener);
	        }
	    }, {
	        key: "onAll",
	        value: function onAll(listener) {
	            this.allListeners.push(listener);
	        }
	    }, {
	        key: "off",
	        value: function off(name, listener) {
	            if (!(name in listeners)) return;
	            var idx = listeners[name].indexOf(listener);
	            if (idx === -1) return;
	            listeners[name].splice(idx, 1);
	        }
	    }, {
	        key: "offAll",
	        value: function offAll(listener) {
	            var idx = this.allListeners.indexOf(listener);
	            if (idx === -1) return;
	            this.allListeners[name].splice(idx, 1);
	        }
	    }]);

	    return Emitter;
	}();

	exports.default = Emitter;
	;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.unbindEvents = unbindEvents;
	exports.initEvents = initEvents;
	exports.onFocus = onFocus;
	exports.onBlur = onBlur;
	exports.onKeydown = onKeydown;
	exports.onKeyup = onKeyup;
	exports.onMousedown = onMousedown;
	exports.onMouseup = onMouseup;
	exports.onMouseover = onMouseover;

	var _cellID = __webpack_require__(10);

	var _events = __webpack_require__(15);

	var _constants = __webpack_require__(12);

	function unbindEvents(self) {
	    (0, _events.unlisten)(self.elem, 'focus');
	    (0, _events.unlisten)(self.elem, 'blur');
	    (0, _events.unlisten)(self.elem, 'keyup');
	    (0, _events.unlisten)(self.elem, 'keydown');
	    (0, _events.unlisten)(self.elem, 'mousedown');
	    (0, _events.unlisten)(self.elem, 'mouseup');
	    (0, _events.unlisten)(self.elem, 'mouseover');
	};
	function initEvents(self) {
	    unbindEvents(self);
	    var elem = self.elem;

	    (0, _events.listen)(elem, 'focus', onFocus.bind(self));
	    (0, _events.listen)(elem, 'blur', onBlur.bind(self));
	    (0, _events.listen)(elem, 'keyup', onKeyup.bind(self));
	    (0, _events.listen)(elem, 'keydown', onKeydown.bind(self));

	    (0, _events.listen)(elem, 'mousedown', onMousedown.bind(self));
	    (0, _events.listen)(elem, 'mouseup', onMouseup.bind(self));
	    (0, _events.listen)(elem, 'mouseover', onMouseover.bind(self));
	};

	function onFocus(e) {
	    var row = e.target.getAttribute('data-row') | 0;
	    var col = e.target.getAttribute('data-col') | 0;
	    e.target.value = (this.data[row] || [])[col] || '';
	    e.target.select(0, e.target.value.length);
	    e.target.parentNode.className = 'websheet-cell-wrapper websheet-has-focus';
	};
	function onBlur(e) {
	    var row = e.target.getAttribute('data-row') | 0;
	    var col = e.target.getAttribute('data-col') | 0;
	    this.setValueAtPosition(row, col, e.target.value);
	    if (this.calculated[row] && col in this.calculated[row]) {
	        e.target.value = this.calculated[row][col];
	    }
	    e.target.parentNode.className = 'websheet-cell-wrapper';
	};
	function onKeydown(e) {
	    var next;
	    if (e.keyCode === 37 && e.target.selectionStart === 0) {
	        next = this.getCell(e.target.getAttribute('data-id-prev-col'));
	    } else if (e.keyCode === 39 && e.target.selectionEnd === e.target.value.length) {
	        next = this.getCell(e.target.getAttribute('data-id-next-col'));
	    }
	    if (next) {
	        next.focus();
	        e.preventDefault();
	    }
	};
	function onKeyup(e) {
	    var next;
	    if (e.keyCode === 13 || e.keyCode === 40) {
	        next = this.getCell(e.target.getAttribute('data-id-next-row'));
	    } else if (e.keyCode === 38) {
	        next = this.getCell(e.target.getAttribute('data-id-prev-row'));
	    }
	    if (next) {
	        next.focus();
	    }
	};
	function onMousedown(e) {
	    var target = e.target;

	    if (!target.classList.contains('websheet-has-focus')) {
	        return;
	    }

	    e.preventDefault();

	    var id = this.dragSource = target.firstChild.getAttribute('data-id');
	    var pos = (0, _cellID.getCellPos)(id);

	    // Assign the value of the currently focused cell's input to the cell, just
	    // incase it changed and hasn't been updated on the blur event.
	    this.setValueAtPosition(pos.row, pos.col, target.firstChild.value);
	    if (e.layerX > target.clientWidth - 10 && e.layerY > target.clientHeight - 10) {
	        // this.data[pos.row] = this.data[pos.row] || [];
	        // this.data[pos.row][pos.col] = target.value;
	        this.dragType = _constants.DRAG_HANDLE;
	        return;
	    }

	    this.dragType = _constants.DRAG_MOVE;
	    this.elem.className += ' websheet-grabbing';
	};
	function onMouseup(e) {
	    var target = e.target;

	    if (this.dragType !== _constants.DRAG_NONE && target.classList.contains('websheet-cell')) {

	        var pos = (0, _cellID.getCellPos)(this.dragSource);
	        var pos2 = (0, _cellID.getCellPos)(target.getAttribute('data-id'));

	        if (this.dragType === _constants.DRAG_MOVE) {
	            this.setValueAtPosition(pos2.row, pos2.col, this.getValueAtPos(pos.row, pos.col) || '');
	            this.clearCell(pos.row, pos.col);
	            e.target.focus();
	        } else if (this.dragType === _constants.DRAG_HANDLE && (pos.row === pos2.row || pos.col === pos2.col)) {
	            var rawSource = this.getValueAtPos(pos.row, pos.col) || '';
	            var parsedSource = rawSource[0] === '=' && parse(rawSource.substr(1));

	            if (pos.row === pos2.row) {
	                var min = Math.min(pos.col, pos2.col);
	                for (var i = min; i <= Math.max(pos.col, pos2.col); i++) {
	                    if (i === pos.col) continue;
	                    if (parsedSource) {
	                        var tmp = parsedSource.clone();
	                        tmp.adjust(0, i - min);
	                        this.setValueAtPosition(pos.row, i, '=' + tmp.toString());
	                    } else {
	                        this.setValueAtPosition(pos.row, i, rawSource);
	                    }
	                }
	            } else if (pos.col === pos2.col) {
	                var min = Math.min(pos.row, pos2.row);
	                for (var i = min; i <= Math.max(pos.row, pos2.row); i++) {
	                    if (i === pos.row) continue;
	                    if (parsedSource) {
	                        var tmp = parsedSource.clone();
	                        tmp.adjust(i - min, 0);
	                        this.setValueAtPosition(i, pos.col, '=' + tmp.toString());
	                    } else {
	                        this.setValueAtPosition(i, pos.col, rawSource);
	                    }
	                }
	            } else {
	                console.error('Cannot drag handle diagonally');
	            }
	        }
	    }
	    this.elem.className = 'websheet';
	    this.dragType = _constants.DRAG_NONE;
	    this.dragSource = null;

	    var existing = this.elem.querySelectorAll('.websheet-cell-hover');
	    for (var i = 0; i < existing.length; i++) {
	        existing[i].classList.remove('websheet-cell-hover');
	    }
	};
	function onMouseover(e) {
	    var _this = this;

	    if (this.dragType === _constants.DRAG_NONE) return;
	    if (!e.target.classList.contains('websheet-cell')) return;

	    var toRemoveClassFrom = [];

	    var existing = this.elem.querySelectorAll('.websheet-cell-hover');
	    for (var i = 0; i < existing.length; i++) {
	        toRemoveClassFrom.push(existing[i].firstChild.dataset.id);
	    }

	    var targetID = e.target.dataset.id;
	    if (targetID === this.dragSource) {
	        return;
	    }

	    if (this.dragType === _constants.DRAG_HANDLE) {
	        var destPos = (0, _cellID.getCellPos)(targetID);
	        var srcPos = (0, _cellID.getCellPos)(this.dragSource);
	        if (destPos.col === srcPos.col) {
	            for (var _i = Math.min(srcPos.row, destPos.row); _i <= Math.max(srcPos.row, destPos.row); _i++) {
	                var tmp = (0, _cellID.getCellID)(_i, srcPos.col);
	                var trcfTmp = toRemoveClassFrom.indexOf(tmp);
	                if (trcfTmp !== -1) {
	                    toRemoveClassFrom.splice(trcfTmp, 1);
	                } else {
	                    this.getCell(tmp).parentNode.classList.add('websheet-cell-hover');
	                }
	            }
	        } else if (destPos.row === srcPos.row) {
	            for (var _i2 = Math.min(srcPos.col, destPos.col); _i2 <= Math.max(srcPos.col, destPos.col); _i2++) {
	                var tmp = (0, _cellID.getCellID)(srcPos.row, _i2);
	                var trcfTmp = toRemoveClassFrom.indexOf(tmp);
	                if (trcfTmp !== -1) {
	                    toRemoveClassFrom.splice(trcfTmp, 1);
	                } else {
	                    this.getCell(tmp).parentNode.classList.add('websheet-cell-hover');
	                }
	            }
	        }
	    } else {
	        e.target.parentNode.classList.add('websheet-cell-hover');
	    }

	    toRemoveClassFrom.forEach(function (id) {
	        _this.getCell(id).parentNode.classList.remove('websheet-cell-hover');
	    });
	};

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.listen = listen;
	exports.unlisten = unlisten;
	var LISTENERS = Symbol('websheets listeners');

	function listen(elem, event, cb) {
	    if (!(LISTENERS in elem)) {
	        elem[LISTENERS] = {};
	    }
	    elem[LISTENERS][event] = elem[LISTENERS][event] || [];
	    elem[LISTENERS][event].push(cb);

	    elem.addEventListener(event, cb, elem !== window);
	};
	function unlisten(elem, event) {
	    if (!elem[LISTENERS] || !elem[LISTENERS][event]) return;
	    elem[LISTENERS][event].forEach(function (listener) {
	        elem.removeEventListener(event, listener, elem !== window);
	    });
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _Emitter = __webpack_require__(13);

	var _Emitter2 = _interopRequireDefault(_Emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var WebSheetContext = function () {
	    function WebSheetContext() {
	        _classCallCheck(this, WebSheetContext);

	        this.sheets = {};
	        this.dependencies = {};

	        this.events = new _Emitter2.default();
	    }

	    _createClass(WebSheetContext, [{
	        key: 'register',
	        value: function register(sheet, name) {
	            var _this = this;

	            this.sheets[name.toUpperCase()] = sheet;
	            sheet.name = name;

	            sheet.valueUpdates.onAll(function (cellID, value) {
	                _this.events.fire('value', name, cellID, value);
	            });

	            sheet.calculatedUpdates.onAll(function (cellID, value) {
	                _this.events.fire('calculated', name, cellID, value);
	            });
	        }
	    }, {
	        key: 'getSheet',
	        value: function getSheet(sheetName) {
	            sheetName = sheetName.toUpperCase();
	            if (!this.sheets.hasOwnProperty(sheetName)) return null;
	            return this.sheets[sheetName];
	        }
	    }, {
	        key: 'lookup',
	        value: function lookup(sheetName, cellID) {
	            sheetName = sheetName.toUpperCase();
	            if (!this.sheets.hasOwnProperty(sheetName)) return null;
	            return this.sheets[sheetName].getCalculatedValueAtID(cellID);
	        }
	    }, {
	        key: 'setDependency',
	        value: function setDependency(fromSheet, fromSheetCellID, toSheetName, toCellID, cb) {
	            toSheetName = toSheetName.toUpperCase();
	            if (!this.sheets.hasOwnProperty(sheetName)) return;
	            var fromID = fromSheet.name.toUpperCase() + '!' + fromSheetCellID;
	            var toID = toSheetName + '!' + toCellID;
	            this.dependencies[fromID] = this.dependencies[fromID] || [];

	            var updateCB = function updateCB(value, type) {
	                // Ignore value updates that preceed calculated updates
	                if (type === 'value' && value[0] === '=') return;
	                cb(value);
	            };

	            this.dependencies[fromID].push([toSheetName, toCellID, updateCB]);

	            this.sheets[toSheetName].valueUpdates.on(toCellID, updateCB);
	            this.sheets[toSheetName].calculatedUpdates.on(toCellID, updateCB);
	        }
	    }, {
	        key: 'clearDependencies',
	        value: function clearDependencies(fromSheet, fromSheetCellID) {
	            var _this2 = this;

	            var fromID = fromSheet.name.toUpperCase() + '!' + fromSheetCellID;
	            if (!this.dependencies.hasOwnProperty(fromID)) return;
	            this.dependencies[fromID].forEach(function (data) {
	                _this2.sheets[data[0]].valueUpdates.off(data[1], data[2]);
	                _this2.sheets[data[0]].calculatedUpdates.off(data[1], data[2]);
	            });
	            this.dependencies[fromID] = [];
	        }
	    }]);

	    return WebSheetContext;
	}();

	exports.default = WebSheetContext;

/***/ }
/******/ ]);